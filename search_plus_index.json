{"./":{"url":"./","title":"简介","keywords":"","body":"security-plus 简介 | Introduce security-plus（简称SP）是基于 spring-boot 搭建的一套后台管理系统,关注安全,敏捷开发. [success] 目标和愿景 安全便捷,开箱即用,灵活方便可扩展. 优点 | Advantages 支持多企业管理：不仅仅适用某一家企业内部管理,还可以拓展成多企业模式,轻松发展成XX平台; 完整的权限体系：基于 rbac 模式实现功能权限,基于 多租户模式 实现数据权限,灵活有效地控制权限; 内置代码生成器：一键生成后端和前端全部代码,甚至于测试文件,此外也支持自定义模板逻辑; 清晰的目录结构：基于 maven 多模块项目,构建标准的 spring-boot 目录结构,有利于降低学习成本; 良好的开发规范：遵循阿里巴巴java开发手册规范,完整的开发测试,提供高质量的软件产品服务; 友好的代码注释: 细致但不繁琐的注释让您阅读源码以及二次开发不再吃力,开发何苦为难开发; druid数据库监控: 随时随地查看数据库连接信息,方便 dba 监控并调优数据库 sql; swagger接口文档: 自动生成 api 接口文档,方便调试开发,降低对接工作时的沟通成本; 快速预览 | Preview 技术选型 | Technology 基础框架: spring-boot ORM框架: Mybatis-Plus Born To Simplify Development 安全框架: Apache Shiro™ Simple. Java. Security. 模板框架: Beetl 新一代Java模板引擎典范 前端框架: hplus 后台主题UI框架 项目结构 | Architecture security-plus 雪之梦后台权限管理系统 ├── security-plus-parent 父项目: 负责维护父子项目关系,本身无任何代码 ├── security-plus-core 核心项目: 子项目,是基础模块,集成常用工具类 └── security-plus-browser 浏览器项目: 子项目,是后端管理系统项目,依赖于核心项目 ├── log ├── src/ | ├── main/ | | ├── java/ | | | └── com.snowdreams1006.securityplus.browser/ | | | ├── base/ 公共配置类以及常用工具类等 | | | ├── module/ 具体业务模块 | | | └── SecurityPlusBrowserApplication 程序入口启动类 | | └── resources/ | | ├── sql 代码生成器产出 sql 以及程序初始化 sql | | ├── static/ 静态资源目录 | | ├── templates/ 模板页面 | | ├── application.yml 总配置文件 | | ├── application-dev.yml 开发环境配置文件 | | ├── application-prod.yml 生产环境配置文件 | | ├── application-test.yml 测试环境配置文件 | | └── banner.txt 程序启动 banner | └── test/ | └── java/ | └── com.snowdreams1006.securityplus.browser/ | ├── base/ | └── module/ ├── target/ └── pom.xml 系统环境 | Environment maven 3.5.3+ jdk 1.8.0_161+ MySQL 5.7+ 下载地址 | Download 最物流企业用户点此访问 svn 服务器 其他用户后续访问 github 服务器 SP 框架暂未开放下载,如有相关需求,欢迎随时联系我! 本地部署 | Documentation 下载 security-plus 源代码,并导入到 Eclipse 或者 IDEA 等 ide 开发工具; 创建 security-plus 数据库,执行 mysql.sql 文件,初始化基本数据; 修改 application-*.yml 配置文件，更新 MySQL连接信息以及其他配置; 在 security-plus-parent 项目下，执行 mvn clean install 下载安装相关依赖; 在 security-plus-browser 项目下,右键 SecurityPlusBrowserApplication 启动; security-plus-browser 项目的默认访问路径：http://localhost:8080/index.page SP 默认账号密码: admin/123456 文档 | Documentation security-plus.pdf pdf 文件 security-plus.mobi mobi 文件 security-plus.epub ePub 文件 如需获取完整版文档,欢迎随时联系我! 版权 | License SP 使用Apache License 2.0开源协议,请放心使用,如有顾虑点击查看协议详情 交流反馈 | Feedback github 主页: snowdreams1006 交流提问区: security-plus-issues 我的QQ号: 513238368 捐赠 | Donate 您的支持是我创作的最大动力,感谢您的肯定! 致谢 | Thanks Java实现权限管理（上） Java实现权限管理（下） RBAC打造通用web管理权限 Linux权限管理之基本权限 Linux权限管理之特殊权限 Java开发企业级权限管理系统 Spring Security开发安全的REST服务 2小时学会Spring Boot Spring Boot进阶之Web进阶 SpringBoot开发常用技术整合 guns 后台管理系统 dp-BOOT 人人开源 参与贡献 | Distribute 维护文档: security-plus.github.io,欢迎参与翻译和修订; 开发文档: security-plus,欢迎志同道合小伙伴加入; 欢迎各路好汉一起来参与完善 security-plus，我们期待你的PR！ Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 22:31:26 "},"docs/use/":{"url":"docs/use/","title":"快速入门","keywords":"","body":"快速入门 如果你看到这里,说明你已初步认同 security-plus权限框架,首先感谢您的认可,下面请和我一起慢慢熟悉雪之梦权限系统! 本章目标 说明: 本章节以 idea 开发工具为例,讲解如何下载安装开发工具,导入svn 到本地空间,如何启动项目 准备好了吗? let's go! Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-07 20:51:44 "},"docs/use/prepare.html":{"url":"docs/use/prepare.html","title":"搭建环境","keywords":"","body":"搭建环境 工欲善其事必先利其器,首先先选择您的开发工具,作者用的是idea,下面就以ida为例搭建开发环境 下载安装idea,选择系统版本,下面作者以 mac 为例,window也同样适用; 开始下载,拼网速的时候到了,耐心等待... 开始安装 idea ,mac 直接拖动安装, window 下一步...,最后启动 idea 软件; Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-07 17:29:58 "},"docs/use/download.html":{"url":"docs/use/download.html","title":"导入项目","keywords":"","body":"导入项目 本文以 svn 为例说明如何下载项目并检出到本地工作空间 打开 idea 找到设置页面,设置下 subversion, 用于连接 svn 服务器; 在 VCS 菜单栏开启 svn 版本控制,连接到 svn 仓库,并检出项目到本地工作空间; Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-07 17:29:33 "},"docs/use/experience.html":{"url":"docs/use/experience.html","title":"运行项目","keywords":"","body":"体验项目 终于可以运行项目了,spring-boot 标准启动方式,默认访问地址: http://localhost:8080/login.page 在本地工作空间中找到项目, 再次启动 idea 并打开 security-plus-parent 项目,等待... 启动项目,打开浏览器体验 http://localhost:8080/login.page; Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-07 17:29:02 "},"docs/practice/":{"url":"docs/practice/","title":"实战演练","keywords":"","body":"实战演练 相信你已经成功运行 security-plus 项目,现在您需要的是如何开发自己的业务,本章节以最简单的 增删改查 基本功能作为切入点,带您进入 security-plus 开发体系中... 本章目标 说明: 以某简单业务为例,讲解如何实现 增删改查 基本功能 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-07 20:52:03 "},"docs/practice/normal.html":{"url":"docs/practice/normal.html","title":"常规开发","keywords":"","body":"常规开发 开发流程: 后端代码 -> 前端页面 -> 分配权限 -> 开发完成 下面以 车辆类型 为例,说明如何进行 增删改查 简单业务,效果如图 ![最终效果预览][normal-preview] 根据业务特点分析,发现 车辆类型 功能和 角色 功能基本类似,所以打算采用复制粘贴的方式快速修改完成! 建立数据表 作者以 mysql workbench 客户端为例,首先找到 sys_role 角色表,并查看表结构; 按需选择 sys_role 数据表字段,右键 copy ,准备复制到 sys_vehicle_type 数据表; 新建 sys_vehilce_type 数据表,并粘贴到该数据表中; 根据实际业务修改数据表结构; sys_vehicle_type CREATE TABLE `sys_vehicle_type` ( `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '车辆类型id', `parent_id` bigint(11) unsigned NOT NULL DEFAULT '0' COMMENT '直接上级id,0表示无上级', `level` varchar(255) NOT NULL DEFAULT '' COMMENT '层级', `num` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '序号', `type` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '类型:1表示牵引车,2表示半挂车,3表示全挂车', `name` varchar(50) NOT NULL DEFAULT '' COMMENT '名称', `remark` varchar(255) NOT NULL DEFAULT '' COMMENT '备注', `state` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '状态,1启用中,2已冻结,3已删除', `is_deleted` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '逻辑删除配置,1表示删除,0表示未删除', `version` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '乐观锁标志位', `owner_enterprise_id` bigint(11) unsigned NOT NULL DEFAULT '0' COMMENT '所有者企业 id', `owner_enterprise_name` varchar(50) NOT NULL DEFAULT '' COMMENT '所有者企业名称', `owner_user_id` bigint(11) unsigned NOT NULL DEFAULT '0' COMMENT '所有者用户 id', `owner_user_name` varchar(50) NOT NULL DEFAULT '' COMMENT '所有者用户名称', `create_enterprise_id` bigint(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建企业 id', `create_enterprise_name` varchar(50) NOT NULL DEFAULT '' COMMENT '创建企业名称', `modified_enterprise_id` bigint(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新企业 id', `modified_enterprise_name` varchar(50) NOT NULL DEFAULT '' COMMENT '更新企业名称', `create_user_id` bigint(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建用户 id', `create_user_name` varchar(50) NOT NULL DEFAULT '' COMMENT '创建用户名称', `modified_user_id` bigint(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新用户 id', `modified_user_name` varchar(50) NOT NULL DEFAULT '' COMMENT '更新企业名称', `tenant_id` bigint(11) unsigned NOT NULL DEFAULT '0' COMMENT '租户 id\\n', `tenant_type` bigint(11) unsigned NOT NULL DEFAULT '0' COMMENT '租户类型,1表示企业租户,2表示个人租户\\n', `tenant_name` varchar(50) NOT NULL DEFAULT '' COMMENT '租户名称', `gmt_create` datetime DEFAULT NULL COMMENT '创建时间', `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`), UNIQUE KEY `id_UNIQUE` (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=303 DEFAULT CHARSET=utf8 COMMENT='系统级别车辆类型表'; 更新 svn 服务器 正式coding前,先保证当前工作空间中代码是最新状态,所以选中可能会更新的目录,右键 subversion -> update Directory... entity 实体类 entity 实体类中各属性与数据表字段一一对应对应，基本规约如下: entity 继承统一基类 BaseEntity ,可根据实际情况决定是否重写某些属性; entity 添加 @Getter @Setter @Builder @NoArgsConstructor @TableName 等注解简化实体类; 类名：大驼峰命名 规范,默认注释同数据表注释,并添加 @author 和 @date 注解说明; 属性名：小驼峰命名规范,默认注释同数据表字段,并添加 @TableField @JsonView @ApiModelProperty 等注解说明; 打开 idea 开发工具,找到 SysRole 角色实体类,右键复制并重命名 SysVehicleType; 重命名成功后系统提示是否加入版本控制,确定,不然每一次新增文件都会提示! 同时打开 SysRole 和 SysVehicleType 文件,选中 SysVehicleType 并右键 Split-vertically 分为左右两个窗口,方便复制粘贴; 根据数据库字段一一映射实体类的属性; SysVehicleType.java package com.snowdreams1006.securityplus.browser.module.system.entity; import com.baomidou.mybatisplus.annotations.TableField; import com.baomidou.mybatisplus.annotations.TableName; import com.baomidou.mybatisplus.mapper.SqlCondition; import com.fasterxml.jackson.annotation.JsonView; import com.snowdreams1006.securityplus.browser.base.entity.BaseEntity; import io.swagger.annotations.ApiModelProperty; import lombok.*; /** * 系统级别车辆类型表 entity * * @author snowdreams1006 * @date 2018-08-07 */ @Getter @Setter @Builder @NoArgsConstructor @AllArgsConstructor @ToString(callSuper = true) @EqualsAndHashCode(callSuper = true) @TableName(\"sys_vehicle_type\") public class SysVehicleType extends BaseEntity { /** * 上级角色id,0表示无上级,简单视图 */ @TableField(\"parent_id\") @JsonView(SimpleView.class) @ApiModelProperty(value = \"上级角色id\") private Long parentId; /** * 层级,详细视图 */ @TableField(value = \"level\", condition = SqlCondition.LIKE) @JsonView(DetailView.class) @ApiModelProperty(value = \"层级\") private String level; /** * 排序,简单视图 */ @TableField(\"num\") @JsonView(SimpleView.class) @ApiModelProperty(value = \"排序\") private Integer num; /** * 类型,简单视图 */ @TableField(\"type\") @JsonView(SimpleView.class) @ApiModelProperty(value = \"类型\") private Integer type; /** * 名称,简单视图 */ @TableField(value = \"name\", condition = SqlCondition.LIKE) @JsonView(SimpleView.class) @ApiModelProperty(value = \"名称\") private String name; } param 参数类 参数类的设计初衷在于区分出实体类和参数类是不一样的! 例如创建时间,修改时间,操作人员等这些字段不能由前端传递给后端,而是应该后端自动判断生成,所以抽象出 param 模型,基本规则如下: param 继承统一基类 BaseParam ,可根据实际情况决定是否重写某些属性; param 添加 @Getter @Setter @Builder @NoArgsConstructor @ApiModel 等注解简化参数类; 类名：大驼峰命名+Param 规范,默认注释业务模型,并添加 @author 和 @date 注解说明; 属性名：小驼峰命名规范,默认注释业务模型,并添加 @NotNull @Min @ApiModelProperty 等注解说明; 找到 SysRoleParam 角色参数类,并复制重命名为 SysVehicleTypeParam,同时打开两个窗口,方便编辑; 根据实际情况,编写 SysVehicleTypeParam 参数类; SysVehicleTypeParam.java package com.snowdreams1006.securityplus.browser.module.system.param; import com.snowdreams1006.securityplus.browser.base.param.BaseParam; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.*; import org.hibernate.validator.constraints.Length; import org.hibernate.validator.constraints.NotBlank; import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; /** * 车辆类型 param * * @author snowdreams1006 * @date 2018-08-07 */ @Getter @Setter @Builder @NoArgsConstructor @AllArgsConstructor @ToString(callSuper = true) @EqualsAndHashCode(callSuper = true) @ApiModel(description = \"车辆类型参数\") public class SysVehicleTypeParam extends BaseParam { /** * 直接上级id,0表示无上级 */ @NotNull(message = \"上级车辆类型id不存在\") @Min(value = 0, message = \"上级车辆类型id必须大于零\") @ApiModelProperty(value = \"直接上级id\", required = true) private Long parentId; /** * 排序 */ @NotNull(message = \"展示顺序不存在\") @Min(value = 0, message = \"展示顺序必须大于零\") @ApiModelProperty(value = \"排序\", required = true) private Integer num; /** * 类型 */ @NotNull(message = \"类型不存在\") @Min(value = 0, message = \"类型必须大于零\") @ApiModelProperty(value = \"类型\", required = true) private Integer type; /** * 名称 */ @NotBlank(message = \"车辆类型名称不存在\") @Length(min = 1, max = 50, message = \"车辆类型名称长度需要在1-50个字符之间\") @ApiModelProperty(value = \"名称\", required = true) private String name; } query 查询类 顾名思义是对查询条件进行抽象而成的 query 模型,用于解决 Map 传递参数引发的诸多问题,基本规则如下: query 继承统一基类 BaseQuery ,可根据实际情况决定是否重写某些属性; query 添加 @Getter @Setter @Builder @NoArgsConstructor 等注解简化参数类; 类名：大驼峰命名+Query 规范,默认注释业务模型,并添加 @author 和 @date 注解说明; 属性名：小驼峰命名规范,默认注释业务模型; 找到 SysRoleQuery 角色查询类,并复制重命名为 SysVehicleTypeQuery,同时打开两个窗口,方便编辑; 根据实际情况,编写 SysVehicleTypeQuery 查询类; SysVehicleTypeQuery.java package com.snowdreams1006.securityplus.browser.module.system.query; import com.snowdreams1006.securityplus.browser.base.query.BaseQuery; import lombok.*; import java.util.List; /** * 车辆类型 query * * @author snowdreams1006 * @date 2018-08-07 */ @Getter @Setter @Builder @NoArgsConstructor @AllArgsConstructor @ToString(callSuper = true) @EqualsAndHashCode(callSuper = true) public class SysVehicleTypeQuery extends BaseQuery { /** * 名称 */ private String name; /** * 类型 */ private List type; } dto 传输类 参数类的设计初衷在于区分出实体类和传输类是不一样的! 例如 ztree 节点中某节点是否选中,是否是父节点等信息,这些都是动态信息,不适合永久存储数据库,因此抽象出 dto 模型动态解决此类需求,基本规则如下: dto 继承自己的实体类 entity ,根据实际情况扩展某些属性或新增属性; dto 添加 @Getter @Setter @NoArgsConstructor @ApiModel 等注解简化参数类; 类名：大驼峰命名+Dto 规范,默认注释业务模型,并添加 @author 和 @date 注解说明; 属性名：小驼峰命名规范,默认注释业务模型; 找到 SysRoleDto 角色传输类,并复制重命名为 SysVehicleTypeDto,同时打开两个窗口,方便编辑; 根据实际情况,编写 SysVehicleTypeDto 传输类; SysVehicleTypeDto package com.snowdreams1006.securityplus.browser.module.system.dto; import com.fasterxml.jackson.annotation.JsonView; import com.google.common.collect.Lists; import com.snowdreams1006.securityplus.browser.base.tools.LevelTools; import com.snowdreams1006.securityplus.browser.module.system.entity.SysVehicleType; import com.snowdreams1006.securityplus.browser.module.system.param.SysVehicleTypeParam; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.*; import org.springframework.beans.BeanUtils; import java.util.List; import java.util.Objects; /** * 车辆类型 dto * * @author snowdreams1006 * @date 2018-05-17 */ @Getter @Setter @NoArgsConstructor @AllArgsConstructor @ToString(callSuper = true) @EqualsAndHashCode(callSuper = true) @ApiModel(description = \"车辆类型对象\") public class SysVehicleTypeDto extends SysVehicleType { /** * 是否为根节点,简单视图 */ @JsonView(SimpleView.class) @ApiModelProperty(value = \"是否为根节点\") private Boolean isRoot; /** * 是否为父节点,简单视图 */ @JsonView(SimpleView.class) @ApiModelProperty(value = \"是否为父节点\") private Boolean isParent; /** * 是否选中,详细视图 */ @JsonView(DetailView.class) @ApiModelProperty(value = \"是否选中\") private Boolean checked; /** * 是否展开,详细视图 */ @JsonView(DetailView.class) @ApiModelProperty(value = \"是否展开\") private Boolean open; /** * 子车辆类型,详细视图 */ @JsonView(DetailView.class) @ApiModelProperty(value = \"子车辆类型\") private List children = Lists.newArrayList(); /** * 默认顶级车辆类型 */ public static SysVehicleTypeDto createRoot() { SysVehicleTypeDto root = new SysVehicleTypeDto(); root.setId(Long.valueOf(LevelTools.ROOT_LEVEL)); root.setParentId(Long.valueOf(LevelTools.ROOT_LEVEL)); root.setLevel(LevelTools.ROOT_LEVEL); root.setName(LevelTools.ROOT_NAME); root.setType(Integer.valueOf(LevelTools.ROOT_LEVEL)); root.setNum(Integer.valueOf(LevelTools.ROOT_LEVEL)); root.setIsRoot(true); root.setIsParent(true); root.setChecked(true); root.setOpen(true); return root; } /** * 将车辆类型entity适配成车辆类型dto * * @param sysVehicleType 车辆类型entity * @return 车辆类型dto */ public static SysVehicleTypeDto entityAdaptDto(SysVehicleType sysVehicleType) { //若接收null,则返回 null, 则具体逻由调用者处理 if (Objects.isNull(sysVehicleType)) { return null; } SysVehicleTypeDto sysVehicleTypeDto = new SysVehicleTypeDto(); BeanUtils.copyProperties(sysVehicleType, sysVehicleTypeDto); return sysVehicleTypeDto; } /** * 将车辆类型entity适配成车辆类型param * * @param sysVehicleType 车辆类型entity * @return 车辆类型param */ public static SysVehicleTypeParam entityAdaptParam(SysVehicleType sysVehicleType) { //若接收null,则返回 null, 则具体逻由调用者处理 if (Objects.isNull(sysVehicleType)) { return null; } SysVehicleTypeParam sysVehicleTypeParam = new SysVehicleTypeParam(); BeanUtils.copyProperties(sysVehicleType, sysVehicleTypeParam); return sysVehicleTypeParam; } /** * 将车辆类型dto适配成车辆类型entity * * @param sysVehicleTypeDto 车辆类型 dto * @return 车辆类型entity */ public static SysVehicleType dtoAdaptEntity(SysVehicleTypeDto sysVehicleTypeDto) { //若 接收null,则返回 null, 则具体逻由调用者处理 if (Objects.isNull(sysVehicleTypeDto)) { return null; } SysVehicleType sysVehicleType = new SysVehicleType(); BeanUtils.copyProperties(sysVehicleTypeDto, sysVehicleType); return sysVehicleType; } /** * 将车辆类型dto适配成车辆类型param * * @param sysVehicleTypeDto 车辆类型 dto * @return 车辆类型entity */ public static SysVehicleTypeParam dtoAdaptParam(SysVehicleTypeDto sysVehicleTypeDto) { //若 接收null,则返回 null, 则具体逻由调用者处理 if (Objects.isNull(sysVehicleTypeDto)) { return null; } SysVehicleTypeParam sysVehicleTypeParam = new SysVehicleTypeParam(); BeanUtils.copyProperties(sysVehicleTypeDto, sysVehicleTypeParam); return sysVehicleTypeParam; } /** * 将车辆类型param适配成车辆类型entity * * @param sysVehicleTypeParam 车辆类型param * @return 车辆类型entity */ public static SysVehicleType paramAdaptEntity(SysVehicleTypeParam sysVehicleTypeParam) { //若 接收null,则返回 null, 则具体逻由调用者处理 if (Objects.isNull(sysVehicleTypeParam)) { return null; } SysVehicleType sysVehicleType = new SysVehicleType(); BeanUtils.copyProperties(sysVehicleTypeParam, sysVehicleType); return sysVehicleType; } /** * 将车辆类型param适配成车辆类型dto * * @param sysVehicleTypeParam 车辆类型param * @return 车辆类型dto */ public static SysVehicleTypeDto paramAdaptDto(SysVehicleTypeParam sysVehicleTypeParam) { //若 接收null,则返回 null, 则具体逻由调用者处理 if (Objects.isNull(sysVehicleTypeParam)) { return null; } SysVehicleTypeDto sysVehicleTypeDto = new SysVehicleTypeDto(); BeanUtils.copyProperties(sysVehicleTypeParam, sysVehicleTypeDto); return sysVehicleTypeDto; } } mapper.java 基本规则如下: mapper 继承自己的基类 BaseMapper ,根据实际情况扩展自定义sql语句; 类名：大驼峰命名+Mapper 规范,默认注释同数据表注释,并添加 @author 和 @date 注解说明; 找到 SysRoleMapper 角色 mapper 类,并复制重命名为 SysVehicleTypeMapper,同时打开两个窗口,方便编辑; 根据实际情况,编写 SysVehicleTypeMapper 接口; SysVehicleTypeMapper.java package com.snowdreams1006.securityplus.browser.module.system.mapper; import com.baomidou.mybatisplus.mapper.BaseMapper; import com.baomidou.mybatisplus.plugins.Page; import com.snowdreams1006.securityplus.browser.module.system.dto.SysVehicleTypeDto; import com.snowdreams1006.securityplus.browser.module.system.entity.SysVehicleType; import com.snowdreams1006.securityplus.browser.module.system.query.SysVehicleTypeQuery; import org.apache.ibatis.annotations.Param; import java.util.List; /** * 系统级别车辆类型表 mapper * * @author snowdreams1006 * @date 2018-08-07 */ public interface SysVehicleTypeMapper extends BaseMapper { /** * 查询当前车辆类型的后代车辆类型 * * @param parent 当前车辆类型 * @param sysVehicleTypeQuery 后代车辆类型过滤条件 * @return 后代车辆类型 */ List listDescendant(@Param(\"parent\") SysVehicleTypeDto parent, @Param(\"sysVehicleTypeQuery\") SysVehicleTypeQuery sysVehicleTypeQuery); /** * 查询当前车辆类型的子车辆类型 * * @param parent 当前车辆类型 * @param sysVehicleTypeQuery 子车辆类型过滤条件 * @return 子车辆类型 */ List listChildren(@Param(\"parent\") SysVehicleTypeDto parent, @Param(\"sysVehicleTypeQuery\") SysVehicleTypeQuery sysVehicleTypeQuery); /** * 查询当前车辆类型的子车辆类型统计值 * * @param parent 当前车辆类型 * @param sysVehicleTypeQuery 子车辆类型过滤条件 * @return 子车辆类型统计值 */ Integer countChildren(@Param(\"parent\") SysVehicleTypeDto parent, @Param(\"sysVehicleTypeQuery\") SysVehicleTypeQuery sysVehicleTypeQuery); /** * 分页查询车辆类型 * * @param page 分页条件 * @param parent 当前车辆类型 * @param sysVehicleTypeQuery 查询条件 * @return 车辆类型列表 */ List listPage(@Param(\"page\") Page page, @Param(\"parent\") SysVehicleTypeDto parent, @Param(\"sysVehicleTypeQuery\") SysVehicleTypeQuery sysVehicleTypeQuery); /** * 条件查询车辆类型 * * @param sysVehicleTypeQuery 查询条件 * @return 车辆类型列表 */ List listCondition(@Param(\"sysVehicleTypeQuery\") SysVehicleTypeQuery sysVehicleTypeQuery); } mapper.xml 基本规则如下: resultMap 的 id=entity+BaseResultMap,例如 id=\"sysVehicleTypeBaseResultMap\"; sql 的 id=entityBaseColumns,例如 sysVehicleTypeBaseColumns 找到 SysRoleMapper.xml 角色 mapper.xml 文件,并复制重命名为 SysVehicleTypeMapper.xml,同时打开两个窗口,方便编辑; 根据实际情况,编写 SysVehicleTypeMapper.xml 文件; SysVehicleTypeMapper.xml id, parent_id, level, num, type, name, remark, state, is_deleted, version, owner_enterprise_id, owner_enterprise_name, owner_user_id, owner_user_name, create_enterprise_id, create_enterprise_name, modified_enterprise_id, modified_enterprise_name, create_user_id, create_user_name, modified_user_id, modified_user_name, tenant_id, tenant_type, tenant_name, gmt_create, gmt_modified select from sys_vehicle_type is_deleted = 0 AND state != 3 AND level like CONCAT(\"%\",#{parent.level},\".\",#{parent.id},\"%\") AND name like CONCAT(\"%\",TRIM(#{sysVehicleTypeQuery.name}),\"%\") 0\"> AND type IN #{typeItem} AND gmt_create BETWEEN #{sysVehicleTypeQuery.startDate} AND #{sysVehicleTypeQuery.endDate} order by level ,num ASC select from sys_vehicle_type is_deleted = 0 AND state != 3 AND parent_id = #{parent.id} AND name like CONCAT(\"%\",TRIM(#{sysVehicleTypeQuery.name}),\"%\") 0\"> AND type IN #{typeItem} AND gmt_create BETWEEN #{sysVehicleTypeQuery.startDate} AND #{sysVehicleTypeQuery.endDate} order by level ,num ASC select count(*) from sys_vehicle_type is_deleted = 0 AND state != 3 AND parent_id = #{parent.id} AND name like CONCAT(\"%\",TRIM(#{sysVehicleTypeQuery.name}),\"%\") 0\"> AND type IN #{typeItem} AND gmt_create BETWEEN #{sysVehicleTypeQuery.startDate} AND #{sysVehicleTypeQuery.endDate} select from sys_vehicle_type is_deleted = 0 AND state != 3 AND parent_id = #{parent.id} AND name like CONCAT(\"%\",TRIM(#{sysVehicleTypeQuery.name}),\"%\") 0\"> AND type IN #{typeItem} AND gmt_create BETWEEN #{sysVehicleTypeQuery.startDate} AND #{sysVehicleTypeQuery.endDate} select from sys_vehicle_type is_deleted = 0 AND state != 3 AND id = #{sysVehicleTypeQuery.id} AND name like CONCAT(\"%\",TRIM(#{sysVehicleTypeQuery.name}),\"%\") 0\"> AND type IN #{typeItem} AND gmt_create BETWEEN #{sysVehicleTypeQuery.startDate} AND #{sysVehicleTypeQuery.endDate} order by level ,num ASC mapperTest 测试目的在于检验 mybaits-plus 通用 sql 是否可用,以及自定义 sql 是否正常运行,因此只测试正常请求时表现如何,基本规则如下: mapperTest 继承统一基类 BaseTest ,可根据实际情况决定是否重写某些方法; 测试方法名: test+(大写字母)+(方法名)+SuccessWith+(条件); 找到 SysRoleMapperTest 角色 mapperTest 测试类,并复制重命名为 SysVehicleTypeMapperTest,同时打开两个窗口,方便编辑; 根据实际情况,编写 SysVehicleTypeMapperTest 文件; SysVehicleTypeMapperTest package com.snowdreams1006.securityplus.browser.module.system.mapper; import com.baomidou.mybatisplus.mapper.EntityWrapper; import com.baomidou.mybatisplus.plugins.Page; import com.google.common.base.Preconditions; import com.snowdreams1006.securityplus.browser.base.BaseTest; import com.snowdreams1006.securityplus.browser.base.enums.BaseStateEnum; import com.snowdreams1006.securityplus.browser.base.enums.RoleTypeEnum; import com.snowdreams1006.securityplus.browser.base.enums.VehicleTypeEnum; import com.snowdreams1006.securityplus.browser.base.tools.LevelTools; import com.snowdreams1006.securityplus.browser.base.tools.ShiroTools; import com.snowdreams1006.securityplus.browser.base.tools.StringTools; import com.snowdreams1006.securityplus.browser.module.system.dto.SysUserDto; import com.snowdreams1006.securityplus.browser.module.system.dto.SysVehicleTypeDto; import com.snowdreams1006.securityplus.browser.module.system.entity.SysVehicleType; import com.snowdreams1006.securityplus.browser.module.system.query.SysVehicleTypeQuery; import com.snowdreams1006.securityplus.core.tools.JacksonTools; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.time.DateUtils; import org.junit.FixMethodOrder; import org.junit.Test; import org.junit.runners.MethodSorters; import javax.annotation.Resource; import java.util.Date; import java.util.List; import java.util.Objects; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.*; /** * 系统级别车辆类型表 mapperTest * * @author snowdreams1006 * @date 2018-07-10 */ @Slf4j @FixMethodOrder(MethodSorters.NAME_ASCENDING) public class SysVehicleTypeMapperTest extends BaseTest { @Resource private SysVehicleTypeMapper sysVehicleTypeMapper; @Test public void testAInsertSuccessWithFullField() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long enterpriseId = currentUser.getOwnerEnterpriseId(); String enterpriseName = currentUser.getOwnerEnterpriseName(); Long userId = currentUser.getOwnerUserId(); String userName = currentUser.getOwnerUserName(); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //初始化影响行数 int result; //默认新增完整字段 SysVehicleType sysVehicleType = SysVehicleType.builder() .parentId(Long.valueOf(LevelTools.ROOT_LEVEL)) .level(LevelTools.ROOT_LEVEL) .num(Integer.MAX_VALUE) .type(RoleTypeEnum.USER.getValue()) .name(\"新增成功\") .build(); sysVehicleType.setRemark(\"测试普通mapper模式下的insert:完整字段\"); sysVehicleType.setState(BaseStateEnum.OK.getValue()); sysVehicleType.setDeleted(false); sysVehicleType.setVersion(1); sysVehicleType.setOwnerEnterpriseId(enterpriseId); sysVehicleType.setOwnerEnterpriseName(enterpriseName); sysVehicleType.setOwnerUserId(userId); sysVehicleType.setOwnerUserName(userName); sysVehicleType.setCreateEnterpriseId(enterpriseId); sysVehicleType.setCreateEnterpriseName(enterpriseName); sysVehicleType.setModifiedEnterpriseId(enterpriseId); sysVehicleType.setModifiedEnterpriseName(enterpriseName); sysVehicleType.setCreateUserId(userId); sysVehicleType.setCreateUserName(userName); sysVehicleType.setModifiedUserId(userId); sysVehicleType.setModifiedUserName(userName); //租户过滤可能会重复添加:取决于是否存在租户约束 if (ShiroTools.isAdmin()) { sysVehicleType.setTenantId(tenantId); } sysVehicleType.setTenantType(tenantType); sysVehicleType.setTenantName(tenantName); sysVehicleType.setGmtCreate(new Date()); sysVehicleType.setGmtModified(new Date()); //新增 result = sysVehicleTypeMapper.insert(sysVehicleType); //再次查询最新属性 sysVehicleType = sysVehicleTypeMapper.selectById(sysVehicleType.getId()); assertThat(result, greaterThan(0)); assertThat(sysVehicleType, notNullValue()); assertThat(sysVehicleType.getId(), notNullValue()); assertThat(sysVehicleType.getParentId(), equalTo(Long.valueOf(LevelTools.ROOT_LEVEL))); assertThat(sysVehicleType.getLevel(), equalTo(LevelTools.ROOT_LEVEL)); assertThat(sysVehicleType.getNum(), equalTo(Integer.MAX_VALUE)); assertThat(sysVehicleType.getType(), equalTo(RoleTypeEnum.USER.getValue())); assertThat(sysVehicleType.getName(), equalTo(\"新增成功\")); assertThat(sysVehicleType.getRemark(), equalTo(\"测试普通mapper模式下的insert:完整字段\")); assertThat(sysVehicleType.getState(), equalTo(BaseStateEnum.OK.getValue())); assertThat(sysVehicleType.getDeleted(), equalTo(false)); assertThat(sysVehicleType.getVersion(), equalTo(1)); assertThat(sysVehicleType.getOwnerEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getOwnerEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getOwnerUserId(), equalTo(userId)); assertThat(sysVehicleType.getOwnerUserName(), equalTo(userName)); assertThat(sysVehicleType.getCreateEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getCreateEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getModifiedEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getModifiedEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getCreateUserId(), equalTo(userId)); assertThat(sysVehicleType.getCreateUserName(), equalTo(userName)); assertThat(sysVehicleType.getModifiedUserId(), equalTo(userId)); assertThat(sysVehicleType.getModifiedUserName(), equalTo(userName)); assertThat(sysVehicleType.getTenantId(), equalTo(tenantId)); assertThat(sysVehicleType.getTenantType(), equalTo(tenantType)); assertThat(sysVehicleType.getTenantName(), equalTo(tenantName)); assertThat(sysVehicleType.getGmtCreate(), notNullValue()); assertThat(sysVehicleType.getGmtModified(), notNullValue()); log.info(\"新增成功: {}\", JacksonTools.object2Json(sysVehicleType)); } @Test public void testAInsertSuccessWithRequiredField() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long enterpriseId = currentUser.getOwnerEnterpriseId(); String enterpriseName = currentUser.getOwnerEnterpriseName(); Long userId = currentUser.getOwnerUserId(); String userName = currentUser.getOwnerUserName(); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //初始化影响行数 int result; //默认新增必须字段 SysVehicleType sysVehicleType = SysVehicleType.builder() .parentId(Long.valueOf(LevelTools.ROOT_LEVEL)) .level(LevelTools.ROOT_LEVEL) .num(Integer.MAX_VALUE) .type(RoleTypeEnum.USER.getValue()) .name(\"新增成功\") .build(); sysVehicleType.setRemark(\"测试普通mapper模式下的insert:必须字段\"); sysVehicleType.setState(BaseStateEnum.OK.getValue()); sysVehicleType.setDeleted(false); sysVehicleType.setVersion(1); sysVehicleType.setOwnerEnterpriseId(enterpriseId); sysVehicleType.setOwnerEnterpriseName(enterpriseName); sysVehicleType.setOwnerUserId(userId); sysVehicleType.setOwnerUserName(userName); //租户过滤可能会重复添加:取决于是否存在租户约束 if (ShiroTools.isAdmin()) { sysVehicleType.setTenantId(tenantId); } sysVehicleType.setTenantType(tenantType); sysVehicleType.setTenantName(tenantName); //新增 result = sysVehicleTypeMapper.insert(sysVehicleType); //再次查询最新属性 sysVehicleType = sysVehicleTypeMapper.selectById(sysVehicleType.getId()); assertThat(result, greaterThan(0)); assertThat(sysVehicleType, notNullValue()); assertThat(sysVehicleType.getId(), notNullValue()); assertThat(sysVehicleType.getParentId(), equalTo(Long.valueOf(LevelTools.ROOT_LEVEL))); assertThat(sysVehicleType.getLevel(), equalTo(LevelTools.ROOT_LEVEL)); assertThat(sysVehicleType.getNum(), equalTo(Integer.MAX_VALUE)); assertThat(sysVehicleType.getType(), equalTo(RoleTypeEnum.USER.getValue())); assertThat(sysVehicleType.getName(), equalTo(\"新增成功\")); assertThat(sysVehicleType.getRemark(), equalTo(\"测试普通mapper模式下的insert:必须字段\")); assertThat(sysVehicleType.getState(), equalTo(BaseStateEnum.OK.getValue())); assertThat(sysVehicleType.getDeleted(), equalTo(false)); assertThat(sysVehicleType.getVersion(), equalTo(1)); assertThat(sysVehicleType.getOwnerEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getOwnerEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getOwnerUserId(), equalTo(userId)); assertThat(sysVehicleType.getOwnerUserName(), equalTo(userName)); assertThat(sysVehicleType.getCreateEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getCreateEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getModifiedEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getModifiedEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getCreateUserId(), equalTo(userId)); assertThat(sysVehicleType.getCreateUserName(), equalTo(userName)); assertThat(sysVehicleType.getModifiedUserId(), equalTo(userId)); assertThat(sysVehicleType.getModifiedUserName(), equalTo(userName)); assertThat(sysVehicleType.getTenantId(), equalTo(tenantId)); assertThat(sysVehicleType.getTenantType(), equalTo(tenantType)); assertThat(sysVehicleType.getTenantName(), equalTo(tenantName)); assertThat(sysVehicleType.getGmtCreate(), notNullValue()); assertThat(sysVehicleType.getGmtModified(), notNullValue()); log.info(\"新增成功: {}\", JacksonTools.object2Json(sysVehicleType)); } @Test public void testBUpdateByIdSuccessWithSelectiveFiled() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long enterpriseId = currentUser.getOwnerEnterpriseId(); String enterpriseName = currentUser.getOwnerEnterpriseName(); Long userId = currentUser.getOwnerUserId(); String userName = currentUser.getOwnerUserName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //初始化影响行数 int result; //测试数据 SysVehicleType sysVehicleType = prepareTestData(null); sysVehicleType.setNum(1); sysVehicleType.setName(\"更新成功\"); sysVehicleType.setRemark(\"测试普通mapper模式下的updateById:可选字段\"); //更新 result = sysVehicleTypeMapper.updateById(sysVehicleType); //再次查询最新属性 sysVehicleType = sysVehicleTypeMapper.selectById(sysVehicleType.getId()); assertThat(result, greaterThan(0)); assertThat(sysVehicleType, notNullValue()); assertThat(sysVehicleType.getId(), notNullValue()); assertThat(sysVehicleType.getNum(), equalTo(1)); assertThat(sysVehicleType.getName(), equalTo(\"更新成功\")); assertThat(sysVehicleType.getRemark(), equalTo(\"测试普通mapper模式下的updateById:可选字段\")); assertThat(sysVehicleType.getModifiedEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getModifiedEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getModifiedUserId(), equalTo(userId)); assertThat(sysVehicleType.getModifiedUserName(), equalTo(userName)); assertThat(sysVehicleType.getGmtModified(), greaterThanOrEqualTo(DateUtils.addSeconds(new Date(), -10))); log.info(\"更新成功: {}\", JacksonTools.object2Json(sysVehicleType)); } @Test public void testCDeleteByIdSuccess() { //初始化影响行数 int result; //测试数据 SysVehicleType sysVehicleType = prepareTestData(null); //删除 result = sysVehicleTypeMapper.deleteById(sysVehicleType.getId()); //再次查询最新属性 sysVehicleType = sysVehicleTypeMapper.selectById(sysVehicleType.getId()); assertThat(result, greaterThan(0)); assertThat(sysVehicleType, nullValue()); log.info(\"删除成功\"); } @Test public void testDSelectPageSuccess() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //分页查询 List sysVehicleTypeList = sysVehicleTypeMapper.selectPage( new Page<>(1, 3), new EntityWrapper() .eq(\"type\", VehicleTypeEnum.SEMITRAILER.getValue()) ); assertThat(sysVehicleTypeList, notNullValue()); assertThat(sysVehicleTypeList, hasSize(greaterThanOrEqualTo(0))); assertThat(sysVehicleTypeList, hasSize(lessThanOrEqualTo(3))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"type\", equalTo(VehicleTypeEnum.SEMITRAILER.getValue())))); if (!ShiroTools.isAdmin()) { assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantId\", equalTo(tenantId)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantType\", equalTo(tenantType)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantName\", equalTo(tenantName)))); } log.info(\"分页查询成功: {}\", JacksonTools.object2Json(sysVehicleTypeList)); } @Test public void testESelectListSuccess() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //查询 List sysVehicleTypeList = sysVehicleTypeMapper.selectList(new EntityWrapper() .eq(\"type\", VehicleTypeEnum.SEMITRAILER.getValue()) ); assertThat(sysVehicleTypeList, notNullValue()); assertThat(sysVehicleTypeList, hasSize(greaterThanOrEqualTo(0))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"type\", equalTo(VehicleTypeEnum.SEMITRAILER.getValue())))); if (!ShiroTools.isAdmin()) { assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantId\", equalTo(tenantId)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantType\", equalTo(tenantType)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantName\", equalTo(tenantName)))); } log.info(\"查询成功: {}\", JacksonTools.object2Json(sysVehicleTypeList)); } @Test public void testFSelectByIdSuccess() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //测试数据 SysVehicleType sysVehicleType = prepareTestData(null); //查询 sysVehicleType = sysVehicleTypeMapper.selectById(sysVehicleType.getId()); assertThat(sysVehicleType, notNullValue()); assertThat(sysVehicleType.getId(), notNullValue()); if (!ShiroTools.isAdmin()) { assertThat(sysVehicleType.getTenantId(), equalTo(tenantId)); assertThat(sysVehicleType.getTenantType(), equalTo(tenantType)); assertThat(sysVehicleType.getTenantName(), equalTo(tenantName)); } log.info(\"查询成功: {}\", JacksonTools.object2Json(sysVehicleType)); } @Test public void testGListDescendantSuccess() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //查询条件 SysVehicleTypeDto parent = SysVehicleTypeDto.createRoot(); SysVehicleTypeQuery descendantQuery = new SysVehicleTypeQuery(); descendantQuery.setName(\"管理员\"); //查询当前车辆类型的后代车辆类型 List sysVehicleTypeList = sysVehicleTypeMapper.listDescendant(parent, descendantQuery); assertThat(sysVehicleTypeList, notNullValue()); assertThat(sysVehicleTypeList, hasSize(greaterThanOrEqualTo(0))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"level\", startsWith(parent.getLevel())))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"name\", containsString(descendantQuery.getName())))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"state\", not(BaseStateEnum.DELETED.getValue())))); if (!ShiroTools.isAdmin()) { assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantId\", equalTo(tenantId)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantType\", equalTo(tenantType)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantName\", equalTo(tenantName)))); } log.info(\"查询成功: {}\", JacksonTools.object2Json(sysVehicleTypeList)); } @Test public void testHListChildrenSuccess() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //查询条件 SysVehicleTypeDto parent = SysVehicleTypeDto.createRoot(); SysVehicleTypeQuery childrenQuery = new SysVehicleTypeQuery(); childrenQuery.setName(\"管理员\"); //查询当前车辆类型的子车辆类型 List sysVehicleTypeList = sysVehicleTypeMapper.listChildren(parent, childrenQuery); assertThat(sysVehicleTypeList, notNullValue()); assertThat(sysVehicleTypeList, hasSize(greaterThanOrEqualTo(0))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"level\", startsWith(parent.getLevel())))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"parentId\", equalTo(parent.getId())))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"name\", containsString(childrenQuery.getName())))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"state\", not(BaseStateEnum.DELETED.getValue())))); if (!ShiroTools.isAdmin()) { assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantId\", equalTo(tenantId)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantType\", equalTo(tenantType)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantName\", equalTo(tenantName)))); } log.info(\"查询成功: {}\", JacksonTools.object2Json(sysVehicleTypeList)); } @Test public void testICountChildrenSuccess() { //初始化影响行数 int result; //查询条件 SysVehicleTypeDto parent = SysVehicleTypeDto.createRoot(); SysVehicleTypeQuery childrenQuery = new SysVehicleTypeQuery(); childrenQuery.setName(\"管理员\"); //查询当前车辆类型的子车辆类型统计值 result = sysVehicleTypeMapper.countChildren(parent, childrenQuery); assertThat(result, greaterThanOrEqualTo(0)); log.info(\"查询成功: {}\", JacksonTools.object2Json(result)); } @Test public void testJListPageSuccess() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //查询条件 Page page = new Page<>(1, 3); SysVehicleTypeDto parent = SysVehicleTypeDto.createRoot(); SysVehicleTypeQuery childrenQuery = new SysVehicleTypeQuery(); childrenQuery.setName(\"管理员\"); //分页查询 List sysVehicleTypeList = sysVehicleTypeMapper.listPage(page, parent, childrenQuery); assertThat(sysVehicleTypeList, notNullValue()); assertThat(sysVehicleTypeList, hasSize(greaterThanOrEqualTo(0))); assertThat(sysVehicleTypeList, hasSize(lessThanOrEqualTo(page.getSize()))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"level\", startsWith(parent.getLevel())))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"parentId\", equalTo(parent.getId())))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"name\", containsString(childrenQuery.getName())))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"state\", not(BaseStateEnum.DELETED.getValue())))); if (!ShiroTools.isAdmin()) { assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantId\", equalTo(tenantId)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantType\", equalTo(tenantType)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantName\", equalTo(tenantName)))); } log.info(\"分页查询成功: {}\", JacksonTools.object2Json(sysVehicleTypeList)); } @Test public void testKListConditionSuccess() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //查询条件 SysVehicleTypeQuery sysVehicleTypeQuery = new SysVehicleTypeQuery(); sysVehicleTypeQuery.setName(\"管理员\"); //条件查询 List results = sysVehicleTypeMapper.listCondition(sysVehicleTypeQuery); assertThat(results, notNullValue()); assertThat(results, hasSize(greaterThanOrEqualTo(0))); assertThat(results, everyItem(hasProperty(\"name\", containsString(sysVehicleTypeQuery.getName())))); assertThat(results, everyItem(hasProperty(\"state\", not(BaseStateEnum.DELETED.getValue())))); if (!ShiroTools.isAdmin()) { assertThat(results, everyItem(hasProperty(\"tenantId\", equalTo(tenantId)))); assertThat(results, everyItem(hasProperty(\"tenantType\", equalTo(tenantType)))); assertThat(results, everyItem(hasProperty(\"tenantName\", equalTo(tenantName)))); } log.info(\"条件查询成功: {}\", JacksonTools.object2Json(results)); } /** * 准备测试数据 * * @param sysVehicleType 自定义的新增车辆类型对象,若 null, 则新增随机车辆类型对象,否则新增指定车辆类型对象 * @return 新增成功的车辆类型对象 */ private SysVehicleType prepareTestData(SysVehicleType sysVehicleType) { //初始化影响行数 int result; //初始化系统车辆类型实体对象 sysVehicleType if (Objects.isNull(sysVehicleType)) { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long enterpriseId = currentUser.getOwnerEnterpriseId(); String enterpriseName = currentUser.getOwnerEnterpriseName(); Long userId = currentUser.getOwnerUserId(); String userName = currentUser.getOwnerUserName(); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"准备测试登录用户: {}\", JacksonTools.object2Json(currentUser)); //默认测试数据 sysVehicleType = SysVehicleType.builder() .parentId(Long.valueOf(LevelTools.ROOT_LEVEL)) .level(LevelTools.ROOT_LEVEL) .num(Integer.MAX_VALUE) .type(RoleTypeEnum.USER.getValue()) .name(\"测试数据:\" + StringTools.getRandomString(6)) .build(); sysVehicleType.setRemark(\"测试普通mapper模式下的insert:\" + StringTools.getRandomString(6)); sysVehicleType.setState(BaseStateEnum.OK.getValue()); sysVehicleType.setDeleted(false); sysVehicleType.setVersion(1); sysVehicleType.setOwnerEnterpriseId(enterpriseId); sysVehicleType.setOwnerEnterpriseName(enterpriseName); sysVehicleType.setOwnerUserId(userId); sysVehicleType.setOwnerUserName(userName); sysVehicleType.setCreateEnterpriseId(enterpriseId); sysVehicleType.setCreateEnterpriseName(enterpriseName); sysVehicleType.setModifiedEnterpriseId(enterpriseId); sysVehicleType.setModifiedEnterpriseName(enterpriseName); sysVehicleType.setCreateUserId(userId); sysVehicleType.setCreateUserName(userName); sysVehicleType.setModifiedUserId(userId); sysVehicleType.setModifiedUserName(userName); //租户过滤可能会重复添加:取决于是否存在租户约束 if (ShiroTools.isAdmin()) { sysVehicleType.setTenantId(tenantId); } sysVehicleType.setTenantType(tenantType); sysVehicleType.setTenantName(tenantName); sysVehicleType.setGmtCreate(new Date()); sysVehicleType.setGmtModified(new Date()); } //新增 result = sysVehicleTypeMapper.insert(sysVehicleType); //再次查询最新属性 sysVehicleType = sysVehicleTypeMapper.selectById(sysVehicleType.getId()); assertThat(result, greaterThan(0)); assertThat(sysVehicleType, notNullValue()); log.info(\"测试数据: {}\", JacksonTools.object2Json(sysVehicleType)); return sysVehicleType; } } entityTest 测试目的在于检验 mybaits-plus 的 ar 模式是否可用,本质上是mapper的语法糖,因此只测试正常请求时表现如何,基本规则如下: entityTest 继承统一基类 BaseTest ,可根据实际情况决定是否重写某些方法; 测试方法名: test+(大写字母)+(方法名)+SuccessWith+(条件); 找到 SysRoleTest 角色 entityTest 测试类,并复制重命名为 SysVehicleTypeTest,同时打开两个窗口,方便编辑; 根据实际情况,编写 SysVehicleTypeTest 文件; SysVehicleTypeTest package com.snowdreams1006.securityplus.browser.module.system.entity; import com.baomidou.mybatisplus.mapper.EntityWrapper; import com.baomidou.mybatisplus.plugins.Page; import com.google.common.base.Preconditions; import com.snowdreams1006.securityplus.browser.base.BaseTest; import com.snowdreams1006.securityplus.browser.base.enums.*; import com.snowdreams1006.securityplus.browser.base.tools.LevelTools; import com.snowdreams1006.securityplus.browser.base.tools.ShiroTools; import com.snowdreams1006.securityplus.browser.base.tools.StringTools; import com.snowdreams1006.securityplus.browser.module.system.dto.SysUserDto; import com.snowdreams1006.securityplus.core.tools.JacksonTools; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.time.DateUtils; import org.junit.FixMethodOrder; import org.junit.Test; import org.junit.runners.MethodSorters; import java.util.Date; import java.util.List; import java.util.Objects; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.*; /** * 系统级别车辆类型表 entityTest * * @author snowdreams1006 * @date 2018-08-07 */ @Slf4j @FixMethodOrder(MethodSorters.NAME_ASCENDING) public class SysVehicleTypeTest extends BaseTest { @Test public void testAInsertSuccessWithFullField() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long enterpriseId = currentUser.getOwnerEnterpriseId(); String enterpriseName = currentUser.getOwnerEnterpriseName(); Long userId = currentUser.getOwnerUserId(); String userName = currentUser.getOwnerUserName(); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //初始化操作成功标识 boolean result; //默认新增完整字段 SysVehicleType sysVehicleType = SysVehicleType.builder() .parentId(Long.valueOf(LevelTools.ROOT_LEVEL)) .level(LevelTools.ROOT_LEVEL) .num(Integer.MAX_VALUE) .type(VehicleTypeEnum.SEMITRAILER.getValue()) .name(\"新增成功\") .build(); sysVehicleType.setRemark(\"测试ActiveRecord模式下的insert:完整字段\"); sysVehicleType.setState(BaseStateEnum.OK.getValue()); sysVehicleType.setDeleted(false); sysVehicleType.setVersion(1); sysVehicleType.setOwnerEnterpriseId(enterpriseId); sysVehicleType.setOwnerEnterpriseName(enterpriseName); sysVehicleType.setOwnerUserId(userId); sysVehicleType.setOwnerUserName(userName); sysVehicleType.setCreateEnterpriseId(enterpriseId); sysVehicleType.setCreateEnterpriseName(enterpriseName); sysVehicleType.setModifiedEnterpriseId(enterpriseId); sysVehicleType.setModifiedEnterpriseName(enterpriseName); sysVehicleType.setCreateUserId(userId); sysVehicleType.setCreateUserName(userName); sysVehicleType.setModifiedUserId(userId); sysVehicleType.setModifiedUserName(userName); //租户过滤可能会重复添加:取决于是否存在租户约束 if (ShiroTools.isAdmin()) { sysVehicleType.setTenantId(tenantId); } sysVehicleType.setTenantType(tenantType); sysVehicleType.setTenantName(tenantName); sysVehicleType.setGmtCreate(new Date()); sysVehicleType.setGmtModified(new Date()); //新增 result = sysVehicleType.insert(); //再次查询最新属性 sysVehicleType = sysVehicleType.selectById(); assertThat(result, equalTo(true)); assertThat(sysVehicleType, notNullValue()); assertThat(sysVehicleType.getId(), notNullValue()); assertThat(sysVehicleType.getParentId(), equalTo(Long.valueOf(LevelTools.ROOT_LEVEL))); assertThat(sysVehicleType.getLevel(), equalTo(LevelTools.ROOT_LEVEL)); assertThat(sysVehicleType.getNum(), equalTo(Integer.MAX_VALUE)); assertThat(sysVehicleType.getType(), equalTo(VehicleTypeEnum.SEMITRAILER.getValue())); assertThat(sysVehicleType.getName(), equalTo(\"新增成功\")); assertThat(sysVehicleType.getRemark(), equalTo(\"测试ActiveRecord模式下的insert:完整字段\")); assertThat(sysVehicleType.getState(), equalTo(BaseStateEnum.OK.getValue())); assertThat(sysVehicleType.getDeleted(), equalTo(false)); assertThat(sysVehicleType.getVersion(), equalTo(1)); assertThat(sysVehicleType.getOwnerEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getOwnerEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getOwnerUserId(), equalTo(userId)); assertThat(sysVehicleType.getOwnerUserName(), equalTo(userName)); assertThat(sysVehicleType.getCreateEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getCreateEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getModifiedEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getModifiedEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getCreateUserId(), equalTo(userId)); assertThat(sysVehicleType.getCreateUserName(), equalTo(userName)); assertThat(sysVehicleType.getModifiedUserId(), equalTo(userId)); assertThat(sysVehicleType.getModifiedUserName(), equalTo(userName)); assertThat(sysVehicleType.getTenantId(), equalTo(tenantId)); assertThat(sysVehicleType.getTenantType(), equalTo(tenantType)); assertThat(sysVehicleType.getTenantName(), equalTo(tenantName)); assertThat(sysVehicleType.getGmtCreate(), notNullValue()); assertThat(sysVehicleType.getGmtModified(), notNullValue()); log.info(\"新增成功: {}\", JacksonTools.object2Json(sysVehicleType)); } @Test public void testAInsertSuccessWithRequiredField() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long enterpriseId = currentUser.getOwnerEnterpriseId(); String enterpriseName = currentUser.getOwnerEnterpriseName(); Long userId = currentUser.getOwnerUserId(); String userName = currentUser.getOwnerUserName(); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //初始化操作成功标识 boolean result; //默认新增必须字段 SysVehicleType sysVehicleType = SysVehicleType.builder() .parentId(Long.valueOf(LevelTools.ROOT_LEVEL)) .level(LevelTools.ROOT_LEVEL) .num(Integer.MAX_VALUE) .type(VehicleTypeEnum.SEMITRAILER.getValue()) .name(\"新增成功\") .build(); sysVehicleType.setRemark(\"测试ActiveRecord模式下的insert:必须字段\"); sysVehicleType.setState(BaseStateEnum.OK.getValue()); sysVehicleType.setDeleted(false); sysVehicleType.setVersion(1); sysVehicleType.setOwnerEnterpriseId(enterpriseId); sysVehicleType.setOwnerEnterpriseName(enterpriseName); sysVehicleType.setOwnerUserId(userId); sysVehicleType.setOwnerUserName(userName); //租户过滤可能会重复添加:取决于是否存在租户约束 if (ShiroTools.isAdmin()) { sysVehicleType.setTenantId(tenantId); } sysVehicleType.setTenantType(tenantType); sysVehicleType.setTenantName(tenantName); //新增 result = sysVehicleType.insert(); //再次查询最新属性 sysVehicleType = sysVehicleType.selectById(); assertThat(result, equalTo(true)); assertThat(sysVehicleType, notNullValue()); assertThat(sysVehicleType.getId(), notNullValue()); assertThat(sysVehicleType.getParentId(), equalTo(Long.valueOf(LevelTools.ROOT_LEVEL))); assertThat(sysVehicleType.getLevel(), equalTo(LevelTools.ROOT_LEVEL)); assertThat(sysVehicleType.getNum(), equalTo(Integer.MAX_VALUE)); assertThat(sysVehicleType.getType(), equalTo(VehicleTypeEnum.SEMITRAILER.getValue())); assertThat(sysVehicleType.getName(), equalTo(\"新增成功\")); assertThat(sysVehicleType.getRemark(), equalTo(\"测试ActiveRecord模式下的insert:必须字段\")); assertThat(sysVehicleType.getState(), equalTo(BaseStateEnum.OK.getValue())); assertThat(sysVehicleType.getDeleted(), equalTo(false)); assertThat(sysVehicleType.getVersion(), equalTo(1)); assertThat(sysVehicleType.getOwnerEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getOwnerEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getOwnerUserId(), equalTo(userId)); assertThat(sysVehicleType.getOwnerUserName(), equalTo(userName)); assertThat(sysVehicleType.getCreateEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getCreateEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getModifiedEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getModifiedEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getCreateUserId(), equalTo(userId)); assertThat(sysVehicleType.getCreateUserName(), equalTo(userName)); assertThat(sysVehicleType.getModifiedUserId(), equalTo(userId)); assertThat(sysVehicleType.getModifiedUserName(), equalTo(userName)); assertThat(sysVehicleType.getTenantId(), equalTo(tenantId)); assertThat(sysVehicleType.getTenantType(), equalTo(tenantType)); assertThat(sysVehicleType.getTenantName(), equalTo(tenantName)); assertThat(sysVehicleType.getGmtCreate(), notNullValue()); assertThat(sysVehicleType.getGmtModified(), notNullValue()); log.info(\"新增成功: {}\", JacksonTools.object2Json(sysVehicleType)); } @Test public void testBUpdateByIdSuccessWithSelectiveFiled() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long enterpriseId = currentUser.getOwnerEnterpriseId(); String enterpriseName = currentUser.getOwnerEnterpriseName(); Long userId = currentUser.getOwnerUserId(); String userName = currentUser.getOwnerUserName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //初始化操作成功标识 boolean result; //测试数据 SysVehicleType sysVehicleType = prepareTestData(null); sysVehicleType.setNum(1); sysVehicleType.setName(\"更新成功\"); sysVehicleType.setRemark(\"测试ActiveRecord模式下的updateById:可选字段\"); //更新 result = sysVehicleType.updateById(); //再次查询最新属性 sysVehicleType = sysVehicleType.selectById(); assertThat(result, equalTo(true)); assertThat(sysVehicleType, notNullValue()); assertThat(sysVehicleType.getId(), notNullValue()); assertThat(sysVehicleType.getNum(), equalTo(1)); assertThat(sysVehicleType.getName(), equalTo(\"更新成功\")); assertThat(sysVehicleType.getRemark(), equalTo(\"测试ActiveRecord模式下的updateById:可选字段\")); assertThat(sysVehicleType.getModifiedEnterpriseId(), equalTo(enterpriseId)); assertThat(sysVehicleType.getModifiedEnterpriseName(), equalTo(enterpriseName)); assertThat(sysVehicleType.getModifiedUserId(), equalTo(userId)); assertThat(sysVehicleType.getModifiedUserName(), equalTo(userName)); assertThat(sysVehicleType.getGmtModified(), greaterThanOrEqualTo(DateUtils.addSeconds(new Date(), -10))); log.info(\"更新成功: {}\", JacksonTools.object2Json(sysVehicleType)); } @Test public void testCDeleteByIdSuccess() { //初始化操作成功标识 boolean result; //测试数据 SysVehicleType sysVehicleType = prepareTestData(null); //删除 result = sysVehicleType.deleteById(); //再次查询最新属性 sysVehicleType = sysVehicleType.selectById(); assertThat(result, equalTo(true)); assertThat(sysVehicleType, nullValue()); log.info(\"删除成功\"); } @Test public void testDSelectPageSuccess() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //分页查询 SysVehicleType sysVehicleType = new SysVehicleType(); Page sysVehicleTypePage = sysVehicleType.selectPage( new Page<>(1, 3), new EntityWrapper() .eq(\"type\", VehicleTypeEnum.SEMITRAILER.getValue()) ); assertThat(sysVehicleTypePage, notNullValue()); assertThat(sysVehicleTypePage.getCurrent(), equalTo(1)); assertThat(sysVehicleTypePage.getSize(), equalTo(3)); assertThat(sysVehicleTypePage.getPages(), greaterThanOrEqualTo(0L)); assertThat(sysVehicleTypePage.getTotal(), greaterThanOrEqualTo(0L)); assertThat(sysVehicleTypePage.getRecords(), hasSize(greaterThanOrEqualTo(0))); assertThat(sysVehicleTypePage.getRecords(), everyItem(hasProperty(\"type\", equalTo(VehicleTypeEnum.SEMITRAILER.getValue())))); if (!ShiroTools.isAdmin()) { assertThat(sysVehicleTypePage.getRecords(), everyItem(hasProperty(\"tenantId\", equalTo(tenantId)))); assertThat(sysVehicleTypePage.getRecords(), everyItem(hasProperty(\"tenantType\", equalTo(tenantType)))); assertThat(sysVehicleTypePage.getRecords(), everyItem(hasProperty(\"tenantName\", equalTo(tenantName)))); } log.info(\"分页查询成功: {}\", JacksonTools.object2Json(sysVehicleTypePage)); } @Test public void testESelectListSuccess() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //查询 SysVehicleType sysVehicleType = new SysVehicleType(); List sysVehicleTypeList = sysVehicleType.selectList(new EntityWrapper() .eq(\"type\", VehicleTypeEnum.SEMITRAILER.getValue()) ); assertThat(sysVehicleTypeList, notNullValue()); assertThat(sysVehicleTypeList, hasSize(greaterThanOrEqualTo(0))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"type\", equalTo(VehicleTypeEnum.SEMITRAILER.getValue())))); if (!ShiroTools.isAdmin()) { assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantId\", equalTo(tenantId)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantType\", equalTo(tenantType)))); assertThat(sysVehicleTypeList, everyItem(hasProperty(\"tenantName\", equalTo(tenantName)))); } log.info(\"查询成功: {}\", JacksonTools.object2Json(sysVehicleTypeList)); } @Test public void testFSelectByIdSuccess() { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"当前登录用户: {}\", JacksonTools.object2Json(currentUser)); //测试数据 SysVehicleType sysVehicleType = prepareTestData(null); //查询 sysVehicleType = sysVehicleType.selectById(); assertThat(sysVehicleType, notNullValue()); assertThat(sysVehicleType.getId(), notNullValue()); if (!ShiroTools.isAdmin()) { assertThat(sysVehicleType.getTenantId(), equalTo(tenantId)); assertThat(sysVehicleType.getTenantType(), equalTo(tenantType)); assertThat(sysVehicleType.getTenantName(), equalTo(tenantName)); } log.info(\"查询成功: {}\", JacksonTools.object2Json(sysVehicleType)); } /** * 准备测试数据 * * @param sysVehicleType 自定义的新增车辆类型对象,若 null, 则新增随机车辆类型对象,否则新增指定车辆类型对象 * @return 新增成功的车辆类型对象 */ private SysVehicleType prepareTestData(SysVehicleType sysVehicleType) { //初始化操作成功标识 boolean result; //初始化系统车辆类型实体对象 sysVehicleType if (Objects.isNull(sysVehicleType)) { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long enterpriseId = currentUser.getOwnerEnterpriseId(); String enterpriseName = currentUser.getOwnerEnterpriseName(); Long userId = currentUser.getOwnerUserId(); String userName = currentUser.getOwnerUserName(); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); log.info(\"准备测试登录用户: {}\", JacksonTools.object2Json(currentUser)); //默认测试数据 sysVehicleType = SysVehicleType.builder() .parentId(Long.valueOf(LevelTools.ROOT_LEVEL)) .level(LevelTools.ROOT_LEVEL) .num(Integer.MAX_VALUE) .type(VehicleTypeEnum.SEMITRAILER.getValue()) .name(\"测试数据:\" + StringTools.getRandomString(6)) .build(); sysVehicleType.setRemark(\"测试ActiveRecord模式下的Insert:\" + StringTools.getRandomString(6)); sysVehicleType.setState(BaseStateEnum.OK.getValue()); sysVehicleType.setDeleted(false); sysVehicleType.setVersion(1); sysVehicleType.setOwnerEnterpriseId(enterpriseId); sysVehicleType.setOwnerEnterpriseName(enterpriseName); sysVehicleType.setOwnerUserId(userId); sysVehicleType.setOwnerUserName(userName); sysVehicleType.setCreateEnterpriseId(enterpriseId); sysVehicleType.setCreateEnterpriseName(enterpriseName); sysVehicleType.setModifiedEnterpriseId(enterpriseId); sysVehicleType.setModifiedEnterpriseName(enterpriseName); sysVehicleType.setCreateUserId(userId); sysVehicleType.setCreateUserName(userName); sysVehicleType.setModifiedUserId(userId); sysVehicleType.setModifiedUserName(userName); //租户过滤可能会重复添加:取决于是否存在租户约束 if (ShiroTools.isAdmin()) { sysVehicleType.setTenantId(tenantId); } sysVehicleType.setTenantType(tenantType); sysVehicleType.setTenantName(tenantName); sysVehicleType.setGmtCreate(new Date()); sysVehicleType.setGmtModified(new Date()); } //新增 result = sysVehicleType.insert(); //再次查询最新属性 sysVehicleType = sysVehicleType.selectById(); assertThat(result, equalTo(true)); assertThat(sysVehicleType, notNullValue()); log.info(\"测试数据: {}\", JacksonTools.object2Json(sysVehicleType)); return sysVehicleType; } } service 基本规则如下: service 继承统一基类 IService ,可根据实际情况决定是否重写某些方法; 类名：I+(大驼峰命名)+Service 规范,默认注释同数据表注释; 方法名: 查询多个结果以 list 开头,获取单个对象以 get开头,获取统计值以 count开头等; 找到 ISysRoleService 角色 service 接口类,并复制重命名为 ISysVehicleTypeService,同时打开两个窗口,方便编辑; 根据实际情况,编写 ISysVehicleTypeService 文件; ISysVehicleTypeService package com.snowdreams1006.securityplus.browser.module.system.service; import com.baomidou.mybatisplus.plugins.Page; import com.baomidou.mybatisplus.service.IService; import com.snowdreams1006.securityplus.browser.module.system.dto.SysVehicleTypeDto; import com.snowdreams1006.securityplus.browser.module.system.entity.SysVehicleType; import com.snowdreams1006.securityplus.browser.module.system.param.SysVehicleTypeParam; import com.snowdreams1006.securityplus.browser.module.system.query.SysVehicleTypeQuery; import org.springframework.transaction.annotation.Transactional; import java.util.List; /** * 系统系别车辆类型表 service * * @author snowdreams1006 * @date 2018-05-17 */ public interface ISysVehicleTypeService extends IService { /** * 同步查询车辆类型树 * * @param sysVehicleTypeQuery 查询条件 * @return 车辆类型树 */ SysVehicleTypeDto getSyncTree(SysVehicleTypeQuery sysVehicleTypeQuery); /** * 异步查询车辆类型树 * * @param sysVehicleTypeQuery 查询条件 * @return 车辆类型列表 */ List listAsyncTree(SysVehicleTypeQuery sysVehicleTypeQuery); /** * 分页查询车辆类型 * * @param page 分页条件 * @param sysVehicleTypeQuery 查询条件 * @return 分页对象 */ Page listPage(Page page, SysVehicleTypeQuery sysVehicleTypeQuery); /** * 条件查询车辆类型 * * @param sysVehicleTypeQuery 查询条件 * @return 车辆类型列表 */ List listCondition(SysVehicleTypeQuery sysVehicleTypeQuery); /** * 精确查询某个车辆类型 * * @param id 车辆类型id * @return 车辆类型对象 */ SysVehicleTypeDto getOne(Long id); /** * 新增某个车辆类型 * * @param sysVehicleTypeParam 新增参数 * @return 新增车辆类型对象 */ @Transactional(rollbackFor = Exception.class) SysVehicleTypeDto addOne(SysVehicleTypeParam sysVehicleTypeParam); /** * 更新某个车辆类型 * * @param sysVehicleTypeParam 更新参数 * @return 更新车辆类型对象 */ @Transactional(rollbackFor = Exception.class) SysVehicleTypeDto updateOne(SysVehicleTypeParam sysVehicleTypeParam); /** * 删除某个车辆类型 * * @param id 车辆类型id */ @Transactional(rollbackFor = Exception.class) void deleteOne(Long id); } serviceImpl serviceImpl 继承统一基类 ServiceImpl ,可根据实际情况决定是否重写某些方法; 类名：I+(大驼峰命名)+Service 规范,默认注释同数据表注释,并加上@Service等注解说明; 方法名: 接口的实现类对外暴露的方法 public,否则 private,尽量不要 protected; 找到 SysRoleServiceImpl 角色 serviceImpl 实现类,并复制重命名为 SysVehicleTypeServiceImpl,同时打开两个窗口,方便编辑; 根据实际情况,编写 SysVehicleTypeServiceImpl 文件; SysVehicleTypeServiceImpl package com.snowdreams1006.securityplus.browser.module.system.service.impl; import com.baomidou.mybatisplus.mapper.EntityWrapper; import com.baomidou.mybatisplus.mapper.Wrapper; import com.baomidou.mybatisplus.plugins.Page; import com.baomidou.mybatisplus.service.impl.ServiceImpl; import com.google.common.base.Preconditions; import com.google.common.collect.ArrayListMultimap; import com.google.common.collect.Lists; import com.google.common.collect.Multimap; import com.google.common.collect.Sets; import com.snowdreams1006.securityplus.browser.base.tools.LevelTools; import com.snowdreams1006.securityplus.browser.base.tools.PageTools; import com.snowdreams1006.securityplus.browser.base.tools.ShiroTools; import com.snowdreams1006.securityplus.browser.module.system.dto.SysUserDto; import com.snowdreams1006.securityplus.browser.module.system.dto.SysVehicleTypeDto; import com.snowdreams1006.securityplus.browser.module.system.entity.SysVehicleType; import com.snowdreams1006.securityplus.browser.module.system.mapper.SysVehicleTypeMapper; import com.snowdreams1006.securityplus.browser.module.system.param.SysVehicleTypeParam; import com.snowdreams1006.securityplus.browser.module.system.query.SysVehicleTypeQuery; import com.snowdreams1006.securityplus.browser.module.system.service.ISysVehicleTypeService; import com.snowdreams1006.securityplus.core.tools.ValidatorTools; import org.apache.commons.collections.CollectionUtils; import org.apache.commons.lang3.BooleanUtils; import org.apache.commons.lang3.time.DateUtils; import org.springframework.stereotype.Service; import javax.annotation.Resource; import java.util.*; import java.util.stream.Collectors; /** * 系统系别车辆类型表 serviceImpl * * @author snowdreams1006 * @date 2018-05-17 */ @Service public class SysVehicleTypeServiceImpl extends ServiceImpl implements ISysVehicleTypeService { @Resource private SysVehicleTypeMapper sysVehicleTypeMapper; @Override public SysVehicleTypeDto getSyncTree(SysVehicleTypeQuery sysVehicleTypeQuery) { //处理公共查询条件 this.handleCommonQuery(sysVehicleTypeQuery); //根据查询条件获取上级车辆类型 SysVehicleTypeDto parent = this.getParentByQuery(sysVehicleTypeQuery); if (Objects.isNull(parent)) { return null; } //上级车辆类型的子车辆类型 List children = Lists.newArrayList(); //查询上级车辆类型的子孙车辆类型(平行列表) List sysVehicleTypeList = sysVehicleTypeMapper.listDescendant(parent, sysVehicleTypeQuery); if (CollectionUtils.isNotEmpty(sysVehicleTypeList)) { //entity列表 适配成 dto列表 List descendant = this.entityListAdaptDtoList(sysVehicleTypeList, sysVehicleTypeQuery); //平行列表 适配成 递归列表 children = this.parallelList2recursiveList(parent, descendant); } //建立父子节点关联 parent.setChildren(children); return parent; } @Override public List listAsyncTree(SysVehicleTypeQuery sysVehicleTypeQuery) { //处理公共查询条件 this.handleCommonQuery(sysVehicleTypeQuery); //根据查询条件获取上级车辆类型 SysVehicleTypeDto parent = this.getParentByQuery(sysVehicleTypeQuery); if (Objects.isNull(parent)) { return null; } //上级车辆类型的子车辆类型 List children = Lists.newArrayList(); //查询上级车辆类型的子车辆类型 List sysVehicleTypeList = sysVehicleTypeMapper.listChildren(parent, sysVehicleTypeQuery); if (CollectionUtils.isNotEmpty(sysVehicleTypeList)) { //entity列表 适配成 dto列表 children = this.entityListAdaptDtoList(sysVehicleTypeList, sysVehicleTypeQuery); } return children; } @Override public Page listPage(Page page, SysVehicleTypeQuery sysVehicleTypeQuery) { //默认分页 if (Objects.isNull(page)) { page = new PageTools().defaultPage(); } //处理公共查询条件 this.handleCommonQuery(sysVehicleTypeQuery); //根据查询条件获取上级车辆类型 SysVehicleTypeDto parent = this.getParentByQuery(sysVehicleTypeQuery); if (Objects.isNull(parent)) { return null; } //上级车辆类型的子车辆类型 List records = Lists.newArrayList(); //分页查询车辆类型 List sysVehicleTypeList = sysVehicleTypeMapper.listPage(page, parent, sysVehicleTypeQuery); if (CollectionUtils.isNotEmpty(sysVehicleTypeList)) { //entity列表 适配成 dto列表 records = this.entityListAdaptDtoList(sysVehicleTypeList, sysVehicleTypeQuery); } //构造分页信息 page.setRecords(records); return page; } @Override public List listCondition(SysVehicleTypeQuery sysVehicleTypeQuery) { //处理公共查询条件 this.handleCommonQuery(sysVehicleTypeQuery); //查询结果列表 List results = Lists.newArrayList(); //条件查询车辆类型 List sysVehicleTypeList = sysVehicleTypeMapper.listCondition(sysVehicleTypeQuery); if (CollectionUtils.isNotEmpty(sysVehicleTypeList)) { //entity列表 适配成 dto列表 results = this.entityListAdaptDtoList(sysVehicleTypeList, sysVehicleTypeQuery); } return results; } @Override public SysVehicleTypeDto getOne(Long id) { //基本数据验证 Preconditions.checkNotNull(id, \"待查询的车辆类型id[null]不存在\"); //精确查询 SysVehicleType sysVehicleType = sysVehicleTypeMapper.selectById(id); //数据不存在,返回 null, 具体逻辑由调用者处理 if (Objects.isNull(sysVehicleType)) { return null; } return this.entityAdaptDto(sysVehicleType); } @Override public SysVehicleTypeDto addOne(SysVehicleTypeParam sysVehicleTypeParam) { //基本数据验证 ValidatorTools.check(sysVehicleTypeParam); //调整参数 adjustParam(sysVehicleTypeParam); //唯一性校验 if (checkExist(sysVehicleTypeParam.getParentId(), sysVehicleTypeParam.getId(), sysVehicleTypeParam.getName())) { throw new IllegalArgumentException(String.format(\"同一层级下的车辆类型[%s]已存在\", sysVehicleTypeParam.getName())); } //param 适配成 entity SysVehicleType sysVehicleType = Preconditions.checkNotNull(SysVehicleTypeDto.paramAdaptEntity(sysVehicleTypeParam)); sysVehicleType.setLevel(LevelTools.calculateLevel(this.getLevel(sysVehicleType.getParentId()), sysVehicleType.getParentId())); //新增 sysVehicleTypeMapper.insert(sysVehicleType); return this.getOne(sysVehicleType.getId()); } @Override public SysVehicleTypeDto updateOne(SysVehicleTypeParam sysVehicleTypeParam) { //基本数据验证 ValidatorTools.check(sysVehicleTypeParam); Preconditions.checkNotNull(sysVehicleTypeParam.getId(), String.format(\"待更新的车辆类型id[%s]不存在\", sysVehicleTypeParam.getName())); //业务逻辑验证 SysVehicleTypeDto beforeDto = Preconditions.checkNotNull(this.getOne(sysVehicleTypeParam.getId())); Preconditions.checkNotNull(beforeDto, String.format(\"待更新的车辆类型[%s]不存在\", beforeDto.getName())); //dto 适配成 entity SysVehicleType before = Preconditions.checkNotNull(SysVehicleTypeDto.dtoAdaptEntity(beforeDto)); //调整更新参数 adjustParam(sysVehicleTypeParam); //唯一性校验 if (checkExist(sysVehicleTypeParam.getParentId(), sysVehicleTypeParam.getId(), sysVehicleTypeParam.getName())) { throw new IllegalArgumentException(String.format(\"同一层级下的车辆类型[%s]已存在\", sysVehicleTypeParam.getName())); } //param 适配成 entity SysVehicleType after = Preconditions.checkNotNull(SysVehicleTypeDto.paramAdaptEntity(sysVehicleTypeParam)); after.setLevel(LevelTools.calculateLevel(this.getLevel(after.getParentId()), after.getParentId())); //同步自动新增字段 syncInsertFillFiled(before, after); //更新子孙车辆类型 this.updateDescendant(before, after); return this.getOne(after.getId()); } @Override public void deleteOne(Long id) { //基本数据验证 Preconditions.checkNotNull(id, \"待删除的车辆类型id[null]不存在\"); //业务逻辑验证 SysVehicleTypeDto sysVehicleTypeDto = this.getOne(id); Preconditions.checkNotNull(sysVehicleTypeDto, String.format(\"待删除的车辆类型id[%s]不存在\", id)); //当前车辆类型存在子车辆类型 if (sysVehicleTypeMapper.countChildren(sysVehicleTypeDto, null) > 0) { throw new IllegalArgumentException(String.format(\"待删除的车辆类型[%s]存在子车辆类型\", sysVehicleTypeDto.getName())); } sysVehicleTypeMapper.deleteById(id); } /** * 处理公共查询条件 * * @param sysVehicleTypeQuery 车辆类型查询条件 */ private void handleCommonQuery(SysVehicleTypeQuery sysVehicleTypeQuery) { //修正查询日期: yyyy-MM-dd 解析成 Date 类型是当日零点,因此结束日期手动推迟一天 if (Objects.nonNull(sysVehicleTypeQuery)) { Date startDate = sysVehicleTypeQuery.getStartDate(); Date endDate = sysVehicleTypeQuery.getEndDate(); //不存在开始日期,则日期查询无效,若不存在结束日期,则默认当前日期 if (Objects.nonNull(startDate)) { if (Objects.nonNull(endDate)) { endDate = DateUtils.addDays(endDate, 1); } else { endDate = new Date(); } sysVehicleTypeQuery.setEndDate(endDate); } } } /** * 根据车辆类型查询条件获取上级车辆类型 * * @param sysVehicleTypeQuery 车辆类型查询条件 * @return 上级车辆类型 */ private SysVehicleTypeDto getParentByQuery(SysVehicleTypeQuery sysVehicleTypeQuery) { //默认上级车辆类型是根节点,level = \"0\" SysVehicleTypeDto parent = SysVehicleTypeDto.createRoot(); //上级车辆类型是否是普通节点 if (Objects.nonNull(sysVehicleTypeQuery)) { Long id = sysVehicleTypeQuery.getId(); boolean normalParentFlag = Objects.nonNull(id) && !Objects.equals(Long.valueOf(LevelTools.ROOT_LEVEL), id); if (normalParentFlag) { parent = this.getOne(id); } } return parent; } /** * 车辆类型entity适配成车辆类型dto * * @param sysVehicleType 车辆类型entity * @return 车辆类型dto */ private SysVehicleTypeDto entityAdaptDto(SysVehicleType sysVehicleType) { //参数 null, 则返回 null, 具体逻辑由调用者处理 if (Objects.isNull(sysVehicleType)) { return null; } //entity静态数据浅拷贝 SysVehicleTypeDto sysVehicleTypeDto = Preconditions.checkNotNull(SysVehicleTypeDto.entityAdaptDto(sysVehicleType)); //dto动态数据在线生成 sysVehicleTypeDto.setIsRoot(false); Boolean isParent = sysVehicleTypeMapper.countChildren(sysVehicleTypeDto, null) > 0; sysVehicleTypeDto.setIsParent(isParent); return sysVehicleTypeDto; } /** * 车辆类型entity列表适配成车辆类型dto列表 * * @param sysVehicleTypeList 车辆类型entity列表 * @return 车辆类型dto列表 */ private List entityListAdaptDtoList(List sysVehicleTypeList, SysVehicleTypeQuery sysVehicleTypeQuery) { //最终输出dto结果列表 List sysVehicleTypeDtoList = Lists.newArrayList(); //集合为空,则返回空集合 if (CollectionUtils.isEmpty(sysVehicleTypeList)) { return sysVehicleTypeDtoList; } //将系统权车辆类型适配成车辆类型dto for (SysVehicleType sysVehicleType : sysVehicleTypeList) { //entity静态数据浅拷贝 SysVehicleTypeDto sysVehicleTypeDto = Preconditions.checkNotNull(SysVehicleTypeDto.entityAdaptDto(sysVehicleType)); //dto动态数据在线生成 sysVehicleTypeDto.setIsRoot(false); //查询子车辆类型统计值 Integer allChildCount = sysVehicleTypeMapper.countChildren(sysVehicleTypeDto, sysVehicleTypeQuery); sysVehicleTypeDto.setIsParent(allChildCount > 0); //entity 转成 dto sysVehicleTypeDtoList.add(sysVehicleTypeDto); } return sysVehicleTypeDtoList; } /** * 根据上级车辆类型及其子孙车辆类型渲染成车辆类型树列表 * * @param parent 上级车辆类型 * @param sysVehicleTypeDtoList 上级车辆类型的子孙车辆类型(平行结构) * @return 车辆类型树列表(递归结构) */ private List parallelList2recursiveList(SysVehicleTypeDto parent, List sysVehicleTypeDtoList) { //父节点的直接子节点dto列表 List children = Lists.newArrayList(); //逐级遍历,不支持跨级递归 if (CollectionUtils.isEmpty(sysVehicleTypeDtoList)) { return children; } //全部子节点车辆类型dto对象map Multimap allDtoMap = ArrayListMultimap.create(); //父节点是根节点还是普通节点 String parentLevel = parent.getLevel(); if (!parent.getIsRoot()) { parentLevel = LevelTools.calculateLevel(parentLevel, parent.getId()); } //将子孙节点组装到指定集合 for (SysVehicleTypeDto sysVehicleTypeDto : sysVehicleTypeDtoList) { //按照 level 层级区分子孙节点 allDtoMap.put(sysVehicleTypeDto.getLevel(), sysVehicleTypeDto); //组装父节点的一级子节点 if (Objects.equals(parentLevel, sysVehicleTypeDto.getLevel())) { children.add(sysVehicleTypeDto); } } //对一级子节点dto列表进行排序 children.sort(sysVehicleTypeDtoComparator); //转变成树形结构 this.recursive2Tree(children, parentLevel, allDtoMap); return children; } /** * 调整参数 * * @param sysVehicleTypeParam 原始参数 */ private void adjustParam(SysVehicleTypeParam sysVehicleTypeParam) { //新增时,无所有者以及租户信息,则自动设置为当前用户参数(注:注意租户 tenantId 属性) boolean autoInsertFlag = Objects.isNull(sysVehicleTypeParam.getId()); if (autoInsertFlag) { //当前登录用户信息 SysUserDto currentUser = ShiroTools.getShiroUser(); Preconditions.checkNotNull(currentUser, \"当前登录用户信息不存在\"); Long enterpriseId = currentUser.getOwnerEnterpriseId(); String enterpriseName = currentUser.getOwnerEnterpriseName(); Long userId = currentUser.getOwnerUserId(); String userName = currentUser.getOwnerUserName(); Long tenantId = currentUser.getTenantId(); Integer tenantType = currentUser.getTenantType(); String tenantName = currentUser.getTenantName(); //所有者信息:可能无\"管理员\"车辆类型(无权设置),也可能有\"管理员\"车辆类型(忽略设置) if (Objects.isNull(sysVehicleTypeParam.getOwnerEnterpriseId())) { sysVehicleTypeParam.setOwnerEnterpriseId(enterpriseId); } if (Objects.isNull(sysVehicleTypeParam.getOwnerEnterpriseName())) { sysVehicleTypeParam.setOwnerEnterpriseName(enterpriseName); } if (Objects.isNull(sysVehicleTypeParam.getOwnerUserId())) { sysVehicleTypeParam.setOwnerUserId(userId); } if (Objects.isNull(sysVehicleTypeParam.getOwnerUserName())) { sysVehicleTypeParam.setOwnerUserName(userName); } //租户 tenantId:无\"管理员\"车辆类型(无权设置,不能设置),有\"管理员\"车辆类型(忽略设置) if (ShiroTools.isAdmin() && Objects.isNull(sysVehicleTypeParam.getTenantId())) { sysVehicleTypeParam.setTenantId(tenantId); } //租户信息:可能无\"管理员\"车辆类型(无权设置),也可能有\"管理员\"车辆类型(忽略设置) if (Objects.isNull(sysVehicleTypeParam.getTenantType())) { sysVehicleTypeParam.setTenantType(tenantType); } if (Objects.isNull(sysVehicleTypeParam.getTenantName())) { sysVehicleTypeParam.setTenantName(tenantName); } } } /** * 检查车辆类型是否已存在 * * @param parentId 上级车辆类型 id * @param id 车辆类型 id, 新增时为空, 修改时非空 * @param name 车辆类型名称 * @return 车辆类型是否存在 */ private boolean checkExist(Long parentId, Long id, String name) { //新增/更新判断是否已存在 Wrapper sysVehicleTypeWrapper = new EntityWrapper<>(); sysVehicleTypeWrapper.eq(\"parent_id\", parentId) .eq(\"name\", name); if (Objects.nonNull(id)) { sysVehicleTypeWrapper.ne(\"id\", id); } return sysVehicleTypeMapper.selectCount(sysVehicleTypeWrapper) > 0; } /** * 查询车辆类型 level 值 * * @param id 车辆类型 id, * @return 车辆类型level, 存在返回 level,不存在时返回\"\" */ private String getLevel(Long id) { SysVehicleType sysVehicleType = sysVehicleTypeMapper.selectById(id); if (sysVehicleType == null) { return \"\"; } return sysVehicleType.getLevel(); } /** * 同步新增填充字段 * * @param before 同步数据源 * @param after 待同步数据 */ private void syncInsertFillFiled(SysVehicleType before, SysVehicleType after) { //获取新增自动填充字段 Long createEnterpriseId = before.getCreateEnterpriseId(); String createEnterpriseName = before.getCreateEnterpriseName(); Long createUserId = before.getCreateUserId(); String createUserName = before.getCreateUserName(); Date gmtCreate = before.getGmtCreate(); //同步更新新增自动填充字段 after.setCreateEnterpriseId(createEnterpriseId); after.setCreateEnterpriseName(createEnterpriseName); after.setCreateUserId(createUserId); after.setCreateUserName(createUserName); after.setGmtCreate(gmtCreate); } /** * 更新子孙车辆类型 * * @param before 更新前车辆类型对象 * @param after 更新后车辆类型对象 */ private void updateDescendant(SysVehicleType before, SysVehicleType after) { //更新前后车辆类型level String beforeLevel = before.getLevel(); String afterLevel = after.getLevel(); //更改父节点,则同步更新子孙节点 level 冗余字段 if (!Objects.equals(beforeLevel, afterLevel)) { //处理当前车辆类型的后代 SysVehicleTypeDto sysVehicleTypeDto = SysVehicleTypeDto.entityAdaptDto(before); List sysVehicleTypeList = sysVehicleTypeMapper.listDescendant(sysVehicleTypeDto, null); //更新子代的 level 冗余字段 if (CollectionUtils.isNotEmpty(sysVehicleTypeList)) { for (SysVehicleType sysVehicleType : sysVehicleTypeList) { String level = sysVehicleType.getLevel(); //更新子孙车辆类型level if (level.startsWith(beforeLevel)) { //更新根节点的前缀 level = afterLevel + level.substring(beforeLevel.length()); sysVehicleType.setLevel(level); } //更新子孙车辆类型 sysVehicleTypeMapper.updateById(sysVehicleType); } } } //更新车辆类型 sysVehicleTypeMapper.updateById(after); } /** * 根据选中车辆类型列表来处理完整车辆类型列表 * * @param allSysVehicleTypeDtoList 完整车辆类型列表 * @param selectedSysVehicleTypeDtoList 选中车辆类型列表 * @return 带有选中状态的完整车辆类型列表 */ private List handleSelectRoleList(List allSysVehicleTypeDtoList, List selectedSysVehicleTypeDtoList) { //完整车辆类型列表非空校验 if (CollectionUtils.isEmpty(allSysVehicleTypeDtoList)) { return Lists.newArrayList(); } //完整车辆类型列表 list 转 set Set allSysVehicleTypeDtoIdSet = allSysVehicleTypeDtoList.stream().map(SysVehicleTypeDto::getId).collect(Collectors.toSet()); //选中车辆类型列表 list 转 set Set selectedSysVehicleTypeDtoIdSet = selectedSysVehicleTypeDtoList.stream().map(SysVehicleTypeDto::getId).collect(Collectors.toSet()); //完整权限与选中权限交集 Sets.SetView selected = Sets.intersection(allSysVehicleTypeDtoIdSet, selectedSysVehicleTypeDtoIdSet); //处理完整权限列表 for (SysVehicleTypeDto sysVehicleTypeDto : allSysVehicleTypeDtoList) { //选中权限节点 if (selected.contains(sysVehicleTypeDto.getId())) { sysVehicleTypeDto.setChecked(true); } else { sysVehicleTypeDto.setChecked(false); } //父节点则展开 if (BooleanUtils.toBooleanDefaultIfNull(sysVehicleTypeDto.getIsParent(), false)) { sysVehicleTypeDto.setOpen(true); } else { sysVehicleTypeDto.setOpen(false); } } return allSysVehicleTypeDtoList; } /** * 以currentList为基础,递归渲染车辆类型树 * * @param currentList 正在遍历的List * @param currentLevel 正在遍历的level * @param allDtoMap 全部节点map */ private void recursive2Tree(List currentList, String currentLevel, Multimap allDtoMap) { //遍历当前节点并和子孙节点建立关系 for (SysVehicleTypeDto sysVehicleTypeDto : currentList) { //下次遍历的层级level String childrenLevel = LevelTools.calculateLevel(currentLevel, sysVehicleTypeDto.getId()); //下次遍历的dtoList List children = (List) allDtoMap.get(childrenLevel); //不支持跨级递归 if (CollectionUtils.isNotEmpty(children)) { //对下次遍历的list排序 children.sort(sysVehicleTypeDtoComparator); //将下次遍历的list作为当前节点的children sysVehicleTypeDto.setChildren(children); //继续迭代 recursive2Tree(children, childrenLevel, allDtoMap); } } } /** * 车辆类型dto 比较器 */ private Comparator sysVehicleTypeDtoComparator = Comparator.comparingInt(SysVehicleType::getNum); } Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-08 00:46:52 "},"docs/practice/smart.html":{"url":"docs/practice/smart.html","title":"敏捷开发","keywords":"","body":"敏捷开发 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-07 20:43:28 "},"docs/rule/":{"url":"docs/rule/","title":"开发规范","keywords":"","body":"开发规范 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/rule/module.html":{"url":"docs/rule/module.html","title":"模块规范","keywords":"","body":"模块规范 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/rule/project.html":{"url":"docs/rule/project.html","title":"工程规范","keywords":"","body":"工程规范 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/rule/domain.html":{"url":"docs/rule/domain.html","title":"领域规范","keywords":"","body":"领域规范 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/rule/test.html":{"url":"docs/rule/test.html","title":"测试规范","keywords":"","body":"测试规范 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/rule/api.html":{"url":"docs/rule/api.html","title":"接口规范","keywords":"","body":"接口规范 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/advance.README.html":{"url":"docs/advance.README.html","title":"开始进阶","keywords":"","body":"开始进阶 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/advance/access.html":{"url":"docs/advance/access.html","title":"功能权限","keywords":"","body":"功能权限 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/advance/data.html":{"url":"docs/advance/data.html","title":"数据权限","keywords":"","body":"数据权限 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/advance/server.html":{"url":"docs/advance/server.html","title":"后端用法","keywords":"","body":"后端用法 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/advance/client.html":{"url":"docs/advance/client.html","title":"前端用法","keywords":"","body":"前端用法 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/advance/custom.html":{"url":"docs/advance/custom.html","title":"高级用法","keywords":"","body":"高级用法 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/advance/paging.html":{"url":"docs/advance/paging.html","title":"分页插件","keywords":"","body":"分页插件 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/advance/optimistic.html":{"url":"docs/advance/optimistic.html","title":"乐观锁插件","keywords":"","body":"乐观锁插件 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/advance/autofill.html":{"url":"docs/advance/autofill.html","title":"公共字段自动填充","keywords":"","body":"公共字段自动填充 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/advance/logic.html":{"url":"docs/advance/logic.html","title":"逻辑删除","keywords":"","body":"逻辑删除 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/advance/tenant.html":{"url":"docs/advance/tenant.html","title":"多租户解析","keywords":"","body":"多租户解析 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/reading/":{"url":"docs/reading/","title":"进阶阅读","keywords":"","body":"进阶阅读 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/reading/maven.html":{"url":"docs/reading/maven.html","title":"maven 简介","keywords":"","body":"maven 简介 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/reading/springboot.html":{"url":"docs/reading/springboot.html","title":"springboot 简介","keywords":"","body":"springboot 简介 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/reading/shiro.html":{"url":"docs/reading/shiro.html","title":"shiro 简介","keywords":"","body":"shiro 简介 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/reading/mybaits-plus.html":{"url":"docs/reading/mybaits-plus.html","title":"mybaits-plus 简介","keywords":"","body":"mybaits-plus 简介 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/reading/ibeetl.html":{"url":"docs/reading/ibeetl.html","title":"ibeetl 简介","keywords":"","body":"ibeetl 简介 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/reading/hplus.html":{"url":"docs/reading/hplus.html","title":"h+ 简介","keywords":"","body":"h+ 简介 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/reading/svn.html":{"url":"docs/reading/svn.html","title":"svn 简介","keywords":"","body":"svn 简介 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/reading/git.html":{"url":"docs/reading/git.html","title":"git 简介","keywords":"","body":"git 简介 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/custom/":{"url":"docs/custom/","title":"高级配置","keywords":"","body":"高级配置 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/custom/project.html":{"url":"docs/custom/project.html","title":"项目配置","keywords":"","body":"项目配置 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/custom/access.html":{"url":"docs/custom/access.html","title":"权限配置","keywords":"","body":"权限配置 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/custom/client.html":{"url":"docs/custom/client.html","title":"前端配置","keywords":"","body":"前端配置 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/custom/template.html":{"url":"docs/custom/template.html","title":"模板配置","keywords":"","body":"模板配置 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/mind/":{"url":"docs/mind/","title":"设计思想","keywords":"","body":"设计思想 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/mind/module.html":{"url":"docs/mind/module.html","title":"模块划分","keywords":"","body":"模块划分 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/mind/access.html":{"url":"docs/mind/access.html","title":"功能权限","keywords":"","body":"功能权限 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/mind/data.html":{"url":"docs/mind/data.html","title":"数据权限","keywords":"","body":"数据权限 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/issue/":{"url":"docs/issue/","title":"常见问题FAQ","keywords":"","body":"常见问题FAQ Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/other.README.html":{"url":"docs/other.README.html","title":"其他","keywords":"","body":"其他 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/oter.contact.html":{"url":"docs/oter.contact.html","title":"联系作者","keywords":"","body":"联系作者 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/other.donate.html":{"url":"docs/other.donate.html","title":"捐赠支持","keywords":"","body":"捐赠支持 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"docs/other/log.html":{"url":"docs/other/log.html","title":"更新日志","keywords":"","body":"更新日志 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:21:51 "},"Glossary.html":{"url":"Glossary.html","keywords":"","body":"电子书 电子书是指将文字、图片、声音、影像等讯息内容数字化的出版物和植入或下载数字化文字、图片、声音、影像等讯息内容的集存储和显示终端于一体的手持阅读器。 Kindle Amazon Kindle 是由 Amazon 设计和销售的电子书阅读器（以及软件平台）。用户可以通过无线网络使用 Amazon Kindle 购买、下载和阅读电子书、报纸、杂志、博客及其他电子媒体。 Copyright © snowdreams1006 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-06 21:55:20 "}}